"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const got_1 = __importDefault(require("got"));
const dateformat_1 = __importDefault(require("dateformat"));
const json_stringify_safe_1 = __importDefault(require("json-stringify-safe"));
const reporter_1 = __importDefault(require("@wdio/reporter"));
const logger_1 = __importDefault(require("@wdio/logger"));
const log = (0, logger_1.default)('@wdio/sumologic-reporter');
const MAX_LINES = 100;
const DATE_FORMAT = 'yyyy-mm-dd HH:mm:ss,l o';
/**
 * Initialize a new sumologic test reporter.
 */
class SumoLogicReporter extends reporter_1.default {
    constructor(options) {
        super(options);
        this._unsynced = [];
        this._isSynchronising = false;
        this._hasRunnerEnd = false;
        this._options = Object.assign({
            // don't create a log file
            stdout: true,
            // define sync interval how often logs get pushed to Sumologic
            syncInterval: 100,
            // endpoint of collector source
            sourceAddress: process.env.SUMO_SOURCE_ADDRESS
        }, options);
        if (typeof this._options.sourceAddress !== 'string') {
            log.error('Sumo Logic requires "sourceAddress" paramater');
        }
        this._interval = global.setInterval(this.sync.bind(this), this._options.syncInterval);
    }
    // @ts-ignore
    get isSynchronised() {
        return this._unsynced.length === 0;
    }
    onRunnerStart(runner) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'runner:start',
            data: runner
        }));
    }
    onSuiteStart(suite) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'suite:start',
            data: suite
        }));
    }
    onTestStart(test) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'test:start',
            data: test
        }));
    }
    onTestSkip(test) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'test:skip',
            data: test
        }));
    }
    onTestPass(test) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'test:pass',
            data: test
        }));
    }
    onTestFail(test) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'test:fail',
            data: test
        }));
    }
    onTestEnd(test) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'test:end',
            data: test
        }));
    }
    onSuiteEnd(suite) {
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'suite:end',
            data: suite
        }));
    }
    onRunnerEnd(runner) {
        this._hasRunnerEnd = true;
        this._unsynced.push((0, json_stringify_safe_1.default)({
            time: (0, dateformat_1.default)(new Date(), DATE_FORMAT),
            event: 'runner:end',
            data: runner
        }));
    }
    async sync() {
        /**
         * clear intervall if everything was synced
         */
        if (this._hasRunnerEnd && this._unsynced.length === 0) {
            clearInterval(this._interval);
        }
        /**
         * don't synchronise logs if
         *  - we've already send out a request and are waiting for the successful response
         *  - we have nothing to synchronise
         *  - there is an invalid source address
         */
        if (this._isSynchronising || this._unsynced.length === 0 || typeof this._options.sourceAddress !== 'string') {
            return;
        }
        const logLines = this._unsynced.slice(0, MAX_LINES).join('\n');
        /**
         * set `isSynchronising` to true so we don't sync when a request is being made
         */
        this._isSynchronising = true;
        log.debug('start synchronization');
        try {
            const resp = await (0, got_1.default)(this._options.sourceAddress, {
                method: 'POST',
                json: logLines
            });
            /**
             * remove transfered logs from log bucket
             */
            this._unsynced.splice(0, MAX_LINES);
            /**
             * reset sync flag so we can sync again
             */
            this._isSynchronising = false;
            return log.debug(`synchronised collector data, server status: ${resp.statusCode}`);
        }
        catch (err) {
            return log.error('failed send data to Sumo Logic:\n', err.stack);
        }
    }
}
exports.default = SumoLogicReporter;
__exportStar(require("./types"), exports);
